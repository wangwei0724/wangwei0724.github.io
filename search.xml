<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[bfc]]></title>
      <url>%2F2017%2F04%2F07%2Fbfc%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[腾讯笔试后知后觉]]></title>
      <url>%2F2017%2F04%2F05%2Fnew-page%2F</url>
      <content type="text"><![CDATA[笔试题目 如下示例： 1：0种分解方法； 2：0种分解方法； 3=2+1 1种分解方法； 4=3+1 =2+1+1 2种分解方法； 5=4+1 =3+2 =3+1+1 =2+2+1 =2+1+1+1 5种分解方法； 6=5+1 =4+2 =4+1+1 =3+2+1 =3+1+1+1 =2+2+1+1= 2+1+1+1+1 共七种分解方法； 以此类推，求整数n共有几种分解方法。（如输入2，输出0） 题目解读 题目中所示的分解方法其实是将一个大整数n分解成m个数相加，但m个数不能是完全相同的。 解题思路 很可惜在笔试时间内没能做出来这道题，当时的思路是如果按照手写分解方法，总是将上一种分解方法的一个数拆开，所以最后一种分解方法永远是2+1+1+…(n-2个1)，所以倒数第二种分解方法就是将最后一种方法中的两个1或者1和2组合起来，即2+2+1+1…(n-4个1)或3+1+1+1..(n-3个1)。但一直没能用代码实现。 笔试结束后稍稍改变了一下思路，如果能先将该数的所有分解方法计算出来，再计算出所有加数完全相同的分解方法数，就能求得题目所要的分解方法次数。基于这个思路，问题的关键就在如何求得n的所有分解方法count1以及加数相同的分解方法count2。 柿子挑软的捏，先解决简单的问题，先求出count2。这个问题可以转换一下思路，如果n可以由i个m相加得到，那么m和i都是n的因数，所以这个问题就转化为求整数n的因数问题，这就只需要遍历从1到n1/2，假设得出结果为x。如果n是一个完全平方数，那2x-1，反之为2x。 接下来要求出count1。既然要求出所有的输出组合，那就意味一定会有一个遍历所有组合的过程，并且这个遍历一定是按照某种顺序的，所以关键问题在如何从第一种分解方法遍历到最后一种分解方法。先看一个例子： 3=1+1+1 =1+2 =2+1 =3 这个过程中的1+2和2+1本质上只是一种分解方法，所以应当先规定一个次序，定义了次序，剩下的就是让程序按照这个顺序执行下去。所以我们让数组从小到大出现，也就是说后一个加数永远大于等于前一个加数，这样就不会出现上面2+1的情况了，这样一来就能保证输出的唯一性了。 剩下的就是递归了，先遍历1开头的组合，当1开头的组合遍历完成时，就开始遍历2开头的，以2开头的分解方法中就没有加数1了，最小的加数为2；可以看出，第一个数最大的情况是取小于等于n/2的最大整数，如果第一个数大于n/2,而后一个数又必须大于n/2,那么两数相加一定会大于你，递归的思路如下： n=1+后续组合n=2+后续组合……n=n/2(前取整)+p (n为偶数时p=n/2,n为奇数时p=(n+1)/2) 思路差不多到这里，接下来是代码实现了。递归函数为total(n,start)，n为需要分解的整数，start表示当前遍历的第一个数字，start主要是为了去重复的。 javascript实现123456789101112131415161718192021222324252627282930313233//从1开始，后面加的每个数都大于等于1//1计算完了从2开始，一直遍历到比number/2小的最大整数var count1 = 0;//记录可能性总数（包括所有加数完全一样）var count2 = 0;//计算所有加数都相等情况的总数function list(number)&#123; if (parseInt(number)==NaN) &#123;//判断输入是否有效 return false; &#125; if (number&lt;3) &#123;//n小于3时直接输出0 return 0; &#125; total(number,1);//从第一个加数为1开始执行递归 for(var m = 1;m&lt;=parseInt(Math.sqrt(number));m++)&#123; if((number/m)==(parseInt(number/m)))&#123;//判断n的因数个数 count2++; &#125; &#125; console.log(count1,count2);//调试，可忽略 //判断n是否是完全平方数，若为完全平方，则根号n被多减去了一次，需要加上 if((parseInt(Math.sqrt(number)))==Math.sqrt(number))&#123; return count1-count2*2+2; &#125;else&#123; return count1-count2*2+1; &#125; &#125;function total(number,start)&#123; for(var i = start;i&lt;=number/2;i++)&#123; total(number-i,i);//从i开始可排除重复 count1++; &#125;&#125;console.log(list(9));//结果为27]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javascript中对象封装]]></title>
      <url>%2F2017%2F03%2F07%2Fmy-new-post%2F</url>
      <content type="text"><![CDATA[javascript中对象封装我们知道，JS是面向对象的。谈到面向对象，就不可避免的要涉及类的概念。不同于java这些强类型语言都有固定的定义类的语法，JS的能使用各种方法实现类和对象的封装。总结了目前想到的几种，后期有补充会继续更新： 1.工厂函数 工厂函数是一个返回特定对象的函数；每次调用这个函数都会生成一个新的对象，所以每个对象用的都有自己的方法版本（比如下面的showinfo），但其实所有对象都是共享的一个方法；所以这里可以进行优化,可以在工厂函数外定义该对象的方法，这样就只需要生成一遍对象方法。 12345678910111213function createPerson(name,age)&#123; var temp=new Object; temp.name=name; temp.age=age; temp.showInfo=function()&#123; console.log(this.name+&apos; is &apos;+this.age); &#125; return temp;//函数最后返回对象&#125;var person1=createPerson(&apos;wang&apos;,23);var person2=createPerson(&quot;he&quot;,25);person1.showInfo();person2.showInfo(); 优化方法: 12345678910function createPerson(name,age)&#123; var temp=new Object; temp.name=name; temp.age=age; temp.showInfo=showInfo; return temp;&#125;function showInfo()&#123; console.log(this.name+&apos; is &apos;+this.age); &#125; 2.构造函数 构造函数是指构造一个函数对象，每次需要用是需要先实例化。不过很显然，每次实例化一个对象都会创建自己的showInfo函数版本。 1234567891011function Person(name,age)&#123; this.name=name; this.age=age; this.showInfo=function()&#123; console.log(this.name+&apos; is &apos;+this.age); &#125;&#125;var person1=new Person(&apos;wang&apos;,23);var person2=new Person(&quot;he&quot;,25);person1.showInfo();person2.showInfo(); 3.原型方法 该方式利用了对象的prototype属性，可把它看成创建新对象所依赖的原型。这里，用空构造函数来设置类名。然后把所有的方法和属性都直接赋予prototype属性。原型方式只能直接赋值，而不能通过给构造函数传递参数初始化属性的值。在用这种方式时，会遇到两个非常讨厌的问题。第一问题是采用这种方式必须创建每个对象后才能改变属性的默认值。而不能在创建每个对象时都会直接有自己所需要的属性值。这点很讨厌。第二个问题在于属性所指的是对象的时候。函数共享不会出现任何问题，但是对象共享却会出现问题（如下文的hobbies）。 12345678910111213function Person()&#123;&#125;Person.prototype.name=&quot;wang&quot;;Person.prototype.age=23;Person.prototype.hobbies=new Array(&quot;basketball&quot;,&quot;shoes&quot;);Person.prototype.showInfo=function()&#123; console.log(this.name+&apos; is &apos;+this.age);&#125;var person1=new Person();var person2=new Person();person1.hobbies.push(&quot;code&quot;);console.log(person1.hobbies);//输出&quot;basketball,shoes,code&quot;console.log(person1.hobbies);//输出&quot;basketball,shoes,code&quot; 4.构造函数+原型方式 这种方式的思想是将上两种思想结合一下，用构造函数定义对象的所有属性（包括普通属性和指向对象的属性），用原型方式定义对象的方法。结果使得所有的函数都只被创建一次，而每个对象都有自己的对象属性实例。 12345678910111213function Person(name,age)&#123; this.name=name; this.age=age; this.hobbies=new Array(&quot;basketball&quot;,&quot;shoes&quot;);&#125;Person.prototype.showInfo=function()&#123; console.log(this.name+&apos; is &apos;+this.age); &#125;var person1=new Person(&apos;wang&apos;,23);var person2=new Person(&quot;he&quot;,25);person1.hobbies.push(&quot;code&quot;);console.log(person1.hobbies);//输出&quot;basketball,shoes,code&quot;console.log(person2.hobbies);//输出&quot;basketball,shoes&quot;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[剑指offer javascript实现]]></title>
      <url>%2F2017%2F03%2F06%2Fhello-world%2F</url>
      <content type="text"><![CDATA[剑指offer javascript实现 1.输入一个链表，从尾到头打印链表每个节点的值 123456789101112function printListFromTailToHead(head)&#123; var node= head; var list=[]; while(node!=null)&#123; list.unshift(node.val); node=node.next; &#125; return list;&#125;module.exports = &#123; printListFromTailToHead : printListFromTailToHead&#125;; 2.请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 12345678function replaceSpace(str)&#123; var arr = str.split(&apos; &apos;); str = arr.join(&apos;%20&apos;); return str;&#125;module.exports = &#123; replaceSpace : replaceSpace&#125;; 3.用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 1234567891011121314151617181920var stack = [];var stack_temp = [];function push(node)&#123; stack.push(node);&#125;function pop()&#123; if(stack_temp.length==0)&#123;//若不为空直接返回之前一步最后压入的元素即可 while(stack.length&gt;0)&#123; stack_temp.push(stack.pop()); &#125; &#125; return stack_temp.pop();&#125;module.exports = &#123; push : push, pop : pop&#125;; 4.把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 123456789101112131415//方法1:这是比较low的解决方法，直接遍历数组，通过前后元素的大小比较确定function minNumberInRotateArray(rotateArray)&#123; if(rotateArray.length==0)&#123; return 0; &#125; for(var i=0;i&lt;rotateArray.length;i++)&#123; if(rotateArray[i+1]&lt;rotateArray[i])&#123; return rotateArray[i+1]; &#125; &#125; &#125;module.exports = &#123; minNumberInRotateArray : minNumberInRotateArray&#125;; 12345678910111213141516171819202122232425262728//方法2效率较高，避免了一个一个比较function minNumberInRotateArray(rotateArray)&#123; if(rotateArray.length==0)&#123; return 0; &#125; var start= 0; var end = rotateArray.length-1; var middle = 0; while(rotateArray[start]&gt;=rotateArray[end])&#123; if(start==end-1)&#123; middle = end; break; &#125; middle=Math.floor((start+end)/2); if(rotateArray[middle]&gt;=rotateArray[start])&#123; start=middle; &#125; else if(rotateArray[middle]&lt;rotateArray[start])&#123; end=middle; &#125; &#125; return rotateArray[middle];&#125;module.exports = &#123; minNumberInRotateArray : minNumberInRotateArray&#125;; 5.大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。 1234567891011121314151617181920function Fibonacci(n)&#123; var sum=0; var first=1; var second=1; if(n==1||n==2)&#123; sum = 1; &#125;else&#123; var i=3; while(i&lt;=n)&#123; sum = first+second; first = second; second = sum; i++; &#125; &#125; return sum;&#125;module.exports = &#123; Fibonacci : Fibonacci&#125;; 6.一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 解题思路：青蛙最后一步可以跳一级或者两级;那么假定第一次跳的是一阶，那么剩下的是n-1个台阶，跳法是f(n-1);假定第一次跳的是2阶，那么剩下的是n-2个台阶，跳法是f(n-2);所以最后一步的跳法f(n)=f(n-1)+f(n-2) 12345678910111213141516171819202122function jumpFloor(number)&#123; if(number==0)&#123; return 0; &#125;else if(number&gt;0&amp;&amp;number&lt;3)&#123; return number; &#125;else&#123; var first =1; var second = 2; var sum; var i=3; while(i&lt;=number)&#123; sum = first+second; first = second; second = sum; i++ &#125; return &gt;; &#125;&#125;module.exports = &#123; jumpFloor : jumpFloor&#125;; 7.一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法 解题思路：若将n级台阶的跳法设为f(n)，可以想到f(n)=f(n-1)+f(n-2)+f(n-3)….+f(1)，而f(n-1)=f(n-2)+f(n-3)….+f(1)，所以f(n)=2f(n-1)。所以代码思路就很清晰了 12345678910function jumpFloorII(number)&#123; if(number == 0)&#123;//特殊情况单独拿出来讨论一下 return 0; &#125;else&#123; return Math.pow(2, number-1) &#125; &#125;module.exports = &#123; jumpFloorII : jumpFloorII&#125;; 8.我们可以用2 1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2 1的小矩形无重叠地覆盖一个2 * n的大矩形，总共有多少种方法？ 解题思路：这和上面一样也是一道斐波那契数列的题目，具体思路和第一个青蛙跳台阶差不多 123456789101112131415161718192021function rectCover(number)&#123; if(number==2||number==1||number==0)&#123; return number; &#125;else&#123; var sum; var first= 1; var second = 2; var i=3; while(i&lt;=number)&#123; sum = first+second; first = second; second = sum; i++; &#125; return sum; &#125; &#125;module.exports = &#123; rectCover : rectCover&#125;; 9.输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 12345678910111213141516function reOrderArray(array)&#123; var first=[];//按顺序存奇数 var second=[]; for(var i=0;i&lt;array.length;i++)&#123; if((array[i]%2)==0)&#123; second.push(array[i]); &#125;else&#123; first.push(array[i]); &#125; &#125; first=first.concat(second); return first;&#125;module.exports = &#123; reOrderArray : reOrderArray&#125;;]]></content>
    </entry>

    
  
  
</search>
