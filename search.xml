<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[javascript中对象封装]]></title>
      <url>%2F2017%2F03%2F07%2Fmy-new-post%2F</url>
      <content type="text"><![CDATA[javascript中对象封装我们知道，JS是面向对象的。谈到面向对象，就不可避免的要涉及类的概念。不同于java这些强类型语言都有固定的定义类的语法，JS的能使用各种方法实现类和对象的封装。总结了目前想到的几种，后期有补充会继续更新： 1.工厂函数 工厂函数是一个返回特定对象的函数；每次调用这个函数都会生成一个新的对象，所以每个对象用的都有自己的方法版本（比如下面的showinfo），但其实所有对象都是共享的一个方法；所以这里可以进行优化,可以在工厂函数外定义该对象的方法，这样就只需要生成一遍对象方法。 12345678910111213function createPerson(name,age)&#123; var temp=new Object; temp.name=name; temp.age=age; temp.showInfo=function()&#123; console.log(this.name+&apos; is &apos;+this.age); &#125; return temp;//函数最后返回对象&#125;var person1=createPerson(&apos;wang&apos;,23);var person2=createPerson(&quot;he&quot;,25);person1.showInfo();person2.showInfo(); 优化方法: 12345678910function createPerson(name,age)&#123; var temp=new Object; temp.name=name; temp.age=age; temp.showInfo=showInfo; return temp;&#125;function showInfo()&#123; console.log(this.name+&apos; is &apos;+this.age); &#125; 2.构造函数 构造函数是指构造一个函数对象，每次需要用是需要先实例化。不过很显然，每次实例化一个对象都会创建自己的showInfo函数版本。 1234567891011function Person(name,age)&#123; this.name=name; this.age=age; this.showInfo=function()&#123; console.log(this.name+&apos; is &apos;+this.age); &#125;&#125;var person1=new Person(&apos;wang&apos;,23);var person2=new Person(&quot;he&quot;,25);person1.showInfo();person2.showInfo(); 3.原型方法 该方式利用了对象的prototype属性，可把它看成创建新对象所依赖的原型。这里，用空构造函数来设置类名。然后把所有的方法和属性都直接赋予prototype属性。原型方式只能直接赋值，而不能通过给构造函数传递参数初始化属性的值。在用这种方式时，会遇到两个非常讨厌的问题。第一问题是采用这种方式必须创建每个对象后才能改变属性的默认值。而不能在创建每个对象时都会直接有自己所需要的属性值。这点很讨厌。第二个问题在于属性所指的是对象的时候。函数共享不会出现任何问题，但是对象共享却会出现问题（如下文的hobbies）。 12345678910111213function Person()&#123;&#125;Person.prototype.name=&quot;wang&quot;;Person.prototype.age=23;Person.prototype.hobbies=new Array(&quot;basketball&quot;,&quot;shoes&quot;);Person.prototype.showInfo=function()&#123; console.log(this.name+&apos; is &apos;+this.age);&#125;var person1=new Person();var person2=new Person();person1.hobbies.push(&quot;code&quot;);console.log(person1.hobbies);//输出&quot;basketball,shoes,code&quot;console.log(person1.hobbies);//输出&quot;basketball,shoes,code&quot; 4.构造函数+原型方式 这种方式的思想是将上两种思想结合一下，用构造函数定义对象的所有属性（包括普通属性和指向对象的属性），用原型方式定义对象的方法。结果使得所有的函数都只被创建一次，而每个对象都有自己的对象属性实例。 12345678910111213function Person(name,age)&#123; this.name=name; this.age=age; this.hobbies=new Array(&quot;basketball&quot;,&quot;shoes&quot;);&#125;Person.prototype.showInfo=function()&#123; console.log(this.name+&apos; is &apos;+this.age); &#125;var person1=new Person(&apos;wang&apos;,23);var person2=new Person(&quot;he&quot;,25);person1.hobbies.push(&quot;code&quot;);console.log(person1.hobbies);//输出&quot;basketball,shoes,code&quot;console.log(person2.hobbies);//输出&quot;basketball,shoes&quot;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[剑指offer javascript实现]]></title>
      <url>%2F2017%2F03%2F06%2Fhello-world%2F</url>
      <content type="text"><![CDATA[剑指offer javascript实现 1.输入一个链表，从尾到头打印链表每个节点的值 123456789101112function printListFromTailToHead(head)&#123; var node= head; var list=[]; while(node!=null)&#123; list.unshift(node.val); node=node.next; &#125; return list;&#125;module.exports = &#123; printListFromTailToHead : printListFromTailToHead&#125;; 2.请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 12345678function replaceSpace(str)&#123; var arr = str.split(&apos; &apos;); str = arr.join(&apos;%20&apos;); return str;&#125;module.exports = &#123; replaceSpace : replaceSpace&#125;; 3.用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 1234567891011121314151617181920var stack = [];var stack_temp = [];function push(node)&#123; stack.push(node);&#125;function pop()&#123; if(stack_temp.length==0)&#123;//若不为空直接返回之前一步最后压入的元素即可 while(stack.length&gt;0)&#123; stack_temp.push(stack.pop()); &#125; &#125; return stack_temp.pop();&#125;module.exports = &#123; push : push, pop : pop&#125;; 4.把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 123456789101112131415//方法1:这是比较low的解决方法，直接遍历数组，通过前后元素的大小比较确定function minNumberInRotateArray(rotateArray)&#123; if(rotateArray.length==0)&#123; return 0; &#125; for(var i=0;i&lt;rotateArray.length;i++)&#123; if(rotateArray[i+1]&lt;rotateArray[i])&#123; return rotateArray[i+1]; &#125; &#125; &#125;module.exports = &#123; minNumberInRotateArray : minNumberInRotateArray&#125;; 12345678910111213141516171819202122232425262728//方法2效率较高，避免了一个一个比较function minNumberInRotateArray(rotateArray)&#123; if(rotateArray.length==0)&#123; return 0; &#125; var start= 0; var end = rotateArray.length-1; var middle = 0; while(rotateArray[start]&gt;=rotateArray[end])&#123; if(start==end-1)&#123; middle = end; break; &#125; middle=Math.floor((start+end)/2); if(rotateArray[middle]&gt;=rotateArray[start])&#123; start=middle; &#125; else if(rotateArray[middle]&lt;rotateArray[start])&#123; end=middle; &#125; &#125; return rotateArray[middle];&#125;module.exports = &#123; minNumberInRotateArray : minNumberInRotateArray&#125;; 5.大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。 1234567891011121314151617181920function Fibonacci(n)&#123; var sum=0; var first=1; var second=1; if(n==1||n==2)&#123; sum = 1; &#125;else&#123; var i=3; while(i&lt;=n)&#123; sum = first+second; first = second; second = sum; i++; &#125; &#125; return sum;&#125;module.exports = &#123; Fibonacci : Fibonacci&#125;; 6.一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 解题思路：青蛙最后一步可以跳一级或者两级;那么假定第一次跳的是一阶，那么剩下的是n-1个台阶，跳法是f(n-1);假定第一次跳的是2阶，那么剩下的是n-2个台阶，跳法是f(n-2);所以最后一步的跳法f(n)=f(n-1)+f(n-2) 12345678910111213141516171819202122function jumpFloor(number)&#123; if(number==0)&#123; return 0; &#125;else if(number&gt;0&amp;&amp;number&lt;3)&#123; return number; &#125;else&#123; var first =1; var second = 2; var sum; var i=3; while(i&lt;=number)&#123; sum = first+second; first = second; second = sum; i++ &#125; return &gt;; &#125;&#125;module.exports = &#123; jumpFloor : jumpFloor&#125;; 7.一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法 解题思路：若将n级台阶的跳法设为f(n)，可以想到f(n)=f(n-1)+f(n-2)+f(n-3)….+f(1)，而f(n-1)=f(n-2)+f(n-3)….+f(1)，所以f(n)=2f(n-1)。所以代码思路就很清晰了 12345678910function jumpFloorII(number)&#123; if(number == 0)&#123;//特殊情况单独拿出来讨论一下 return 0; &#125;else&#123; return Math.pow(2, number-1) &#125; &#125;module.exports = &#123; jumpFloorII : jumpFloorII&#125;; 8.我们可以用2 1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2 1的小矩形无重叠地覆盖一个2 * n的大矩形，总共有多少种方法？ 解题思路：这和上面一样也是一道斐波那契数列的题目，具体思路和第一个青蛙跳台阶差不多 123456789101112131415161718192021function rectCover(number)&#123; if(number==2||number==1||number==0)&#123; return number; &#125;else&#123; var sum; var first= 1; var second = 2; var i=3; while(i&lt;=number)&#123; sum = first+second; first = second; second = sum; i++; &#125; return sum; &#125; &#125;module.exports = &#123; rectCover : rectCover&#125;; 9.输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 12345678910111213141516function reOrderArray(array)&#123; var first=[];//按顺序存奇数 var second=[]; for(var i=0;i&lt;array.length;i++)&#123; if((array[i]%2)==0)&#123; second.push(array[i]); &#125;else&#123; first.push(array[i]); &#125; &#125; first=first.concat(second); return first;&#125;module.exports = &#123; reOrderArray : reOrderArray&#125;;]]></content>
    </entry>

    
  
  
</search>
