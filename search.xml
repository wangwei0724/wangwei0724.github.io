<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[post]]></title>
      <url>%2F2017%2F05%2F06%2Fpost%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[learning]]></title>
      <url>%2F2017%2F04%2F28%2Flearning%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[javascript继承方法]]></title>
      <url>%2F2017%2F04%2F07%2Finherit%2F</url>
      <content type="text"><![CDATA[javascript 继承继承是很多面向对象语言中让人津津乐道的概念，ECMAScript中的继承主要是靠原型链来实现。 1.原型链方法 原型链实现继承的基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法（其实个人认为继承还是主要以方法为主）。简单回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象中包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。所以如果让原型对象等于另一个类型的实例，此时的原型对象就会包含一个指向另一个原型的指针，另一个原型中也包含着一个指向另一个构造函数的指针。如此层层推进，就构成了实例和原型之间的链条。下面提供一个原型链继承的例子。 123456789101112131415function SuperType()&#123; this.property = true;&#125;SuperType.prototype.getValue=function()&#123; return this.property;&#125;function SubType()&#123; this.subProperty = true;&#125;SubType.prototype = new SuperType();SuperType.prototype.getSubValue=function()&#123; return this.subProperty;&#125;var instance = new SubType();console.log(instance.getValue());//true 上面代码其实定义了两个类型：SuperType和SubType，每个类型都属于自己的一个属性和方法。主要在于SubType继承了SuperType，继承的方法是通过创建SuperType的实例并将实例赋给了SubType.prototype，本质上是重写了原型对象。所以结果就是instance指向SubType的原型，SubType又指向了SuperType的原型。getValue方法仍然在SuperType.prototype中，但是property则位于SubType.prototype中。这是因为property是一个实例属性，而getValue是一个原型方法。不过在这里要注意instance.constructer现在是指向SuperType，这是因为SubType.prototype中的constructer被重写了。 使用原型链方法其实有一个小的注意点，我们在创建原型方法时不能使用对象字面量，因为这种方法会重写原型链,如下例： 1234567891011121314151617function SuperType()&#123; this.property = true;&#125;SuperType.prototype.getValue=function()&#123; return this.property;&#125;function SubType()&#123; this.subProperty = true;&#125;SubType.prototype = new SuperType();SuperType.prototype=&#123; getSubValue:function()&#123; return this.subProperty; &#125;&#125;var instance = new SubType();console.log(instance.getValue());//error 除此之外，原型链继承也还是有一些问题的，最主要的是包含引用类型值的原型，如下例： 12345678910111213141516function Super()&#123; this.val = 1; this.arr = [1];&#125;function Sub()&#123; // ...&#125;Sub.prototype = new Super(); var sub1 = new Sub();var sub2 = new Sub();sub1.val = 2;sub1.arr.push(2);alert(sub1.val); // 2alert(sub2.val); // 1alert(sub1.arr); // 1, 2alert(sub2.arr); // 1, 2 原型链的第二个问题就是在创建子类的实例时，不能向超类型的构造函数中传递参数。其实按照我的理解应该说是无法再不影响实例对象的情况下，给超类型的构造函数传递参数，所以平时我一般不考虑用这种方法。 2.借用构造函数 这种方法的思想很简单，就是直接在子类构造函数的内部调用超类构造函数，用call或者apply来改变this的指向，其实就是在我们未来要新创建的Sub实例的环境下调用Super的方法，如下例： 123456789101112131415161718192021function Super(val)&#123; this.val = val; this.arr = [1]; this.fun = function()&#123; // ... &#125;&#125;function Sub(val)&#123; Super.call(this, val); this.name = &apos;sub&apos;; &#125;var sub1 = new Sub(1);var sub2 = new Sub(2);sub1.arr.push(2);console.log(sub1.val); // 1console.log(sub2.val); // 2console.log(sub2.name); // subconsole.log(sub1.arr); // 1, 2console.log(sub2.arr); // 1console.log(sub1.fun === sub2.fun); // false 从上面的例子可以看出来，借用构造函数是可以向超类构造函数中传递参数的，如例子中的name属性。为了确保Super构造函数不会重写子类的属性，可以在调用超类构造函数后，再添加相应的子类。 借用构造函数也是有一定问题的，所有的方法都是在构造函数中定义，函数复用就无从谈起了。而且超类原型中定义的方法对子类是不可见的，结果所有的类型就只能使用构造函数模式了，所以平时我也是很少用这个方法。 3.组合继承 组合继承指的是将原型链和借用构造函数组合到一起的一种继承模式，主要思路就是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样既通过在原型上定义方法实现了函数复用，又能保证每个实例都有自己的属性。 1234567891011121314151617181920function Super(val)&#123; // 只在此处声明基本属性和引用属性 this.val = val; this.arr = [1];&#125;// 在此处声明函数，把实例函数都放在原型对象上，以实现函数复用Super.prototype.fun = function()&#123;&#125;;//Super.prototype.fun3...function Sub(val,name)&#123; Super.call(this,val); this.name = name; &#125;Sub.prototype.sayName = function()&#123; console.log(this.name);&#125;Sub.prototype = new Super(); var sub1 = new Sub(1);var sub2 = new Sub(2);alert(sub1.fun === sub2.fun); // true 上面的例子中，Super构造函数有arr和value两个属性，原型上有fun这个方法。Sub构造函数在调用Super构造函数时传入了val参数，然后有定义了属于自己的name属性。最后将Super的实例赋给Sub的原型，然后在该新原型上定义了sayName方法。这样一来可以让两个不同的Sub实例既拥有属于自己的属性，又可以使用相同的方法。 但是这种方法也不是完全没有缺点的，可以看出在这个过程中超类使用了两次，一次在创建子类原型的时候，另一次是在子类构造函数内部，但是使用过程中，子类的实例属性会屏蔽原型属性，也就是说某些原型属性其实是用不上的，这造成了内存的浪费。 4.原型式继承 这种方法其实没有严格意义上的构造函数，主体思想是基于已有的对象并借助原型构建新的对象。 12345function inherit(obj)&#123; function temp()&#123;&#125;; temp.prototype = obj; return new temp;&#125; 参照上述主题思想，在inherit函数内部先创建一个临时的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回这个临时原型的新实例。本质上讲，这就是对传入对象进行了一次浅复制。这种方法一开始是一个叫克劳克福德的老外提出来的，现在es5中有Object.create()方法，这个方法接收两个参数，一个用作新对象原型的对象，一个为新对象增加额外属性属性的对象。在只传入一个参数的情况下，上述inherit方法和Object.create()方法效果一样。 1234567var person = &#123; name:&apos;wang&apos;, hobbies:[&apos;shoes&apos;,&apos;ballgames&apos;]&#125;;var person1 = Object.create(person);person1.hobbies.push(&apos;code&apos;);console.log(person.hobbies);//&apos;shoes&apos;,&apos;ballgames&apos;,&apos;code&apos; 包含引用类型值的属性始终会共享相应的值，就像原型模式一样。如果不想构建创造函数，只是想让一个对象和另一个对象保持类似的情况下，可以考虑使用原型书继承，别的情况下不建议使用。 update at 2017.04.15 5.寄生式继承 这种方法的思路和寄生构造函数和工厂模式类似，就是创建一个仅用于封装继承过程的函数，该函数的内部以别的方法来增强对象，最后再返回对象。 1234567function createAnother(original)&#123; var clone = Object.create(original); clone.show = function()&#123; // &#125; return clone;&#125; 上述例子中，接收的参宿就是将要作为新对象基础的对象，最后再给clone对象增加新的方法。新的对象不仅有original所有的属性和方法，还有自己的show方法。使用这种继承方法给对象添加函数，会由于不能做到函数复用而降低效率。 6.寄生组合式继承 之前说过组合继承中超类使用了两次从而造成内存浪费，浪费的原因主要是在原型和实例中都会出现重名的属性。寄生组合式继承是通过借用构造函数来继承属性，通过原型链的混成形式来继承方法；基本思路就是不必为了指定子类型的原型而调用超类的构造函数，我们所需要的其实就是一个超类型的副本。简单说就是使用寄生式来继承超类的原型，再将结果给子类的原型。 12345function inheritPrototype(Sub,Super)&#123; var prototype = Object.create(Super.prototype);//创建对象 prototype.constructor = Sub;//增强对象 Sub.prototype = prototype;//指定对象&#125; 上述函数接收两个参数，分别为子类构造函数和超类构造函数。函数内部第一步常见超类原型的一个副本，第二步为创建的副本添加constructer属性，弥补一下因为重写原型而失去的默认的constructer属性，第三部将新创建的对象赋给子类的原型。 1234567891011121314151617181920212223function Super(val)&#123; this.val = val; this.arr = [1];&#125;Super.prototype.fun = function()&#123; alert(this.val);&#125;;function Sub(val,name)&#123; Super.call(this，val); this.name = name; &#125;inheritPrototype(Sub,Super);Sub.prototype.sayName = function()&#123; console.log(this.name);&#125;var sub1 = new Sub(1,&apos;wang&apos;);var sub2 = new Sub(2,&apos;wei&apos;);alert(sub1.fun === sub2.fun); // truesub1.sayName();//wangsub1.arr.push(111);console.log(sub1.arr);//[1,111]console.log(sub2.arr);//[1] 相对于组合继承，这个方法最大的优势就在于他只调用了一席Super构造函数，因此避免了在Sub.prototype上创建不必要的属性，与系统是，原型链还能保持不变，简直完美！！！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[腾讯笔试后知后觉]]></title>
      <url>%2F2017%2F04%2F05%2Fnew-page%2F</url>
      <content type="text"><![CDATA[笔试题目 如下示例： 1：0种分解方法； 2：0种分解方法； 3=2+1 1种分解方法； 4=3+1 =2+1+1 2种分解方法； 5=4+1 =3+2 =3+1+1 =2+2+1 =2+1+1+1 5种分解方法； 6=5+1 =4+2 =4+1+1 =3+2+1 =3+1+1+1 =2+2+1+1= 2+1+1+1+1 共七种分解方法； 以此类推，求整数n共有几种分解方法。（如输入2，输出0） 题目解读 题目中所示的分解方法其实是将一个大整数n分解成m个数相加，但m个数不能是完全相同的。 解题思路 很可惜在笔试时间内没能做出来这道题，当时的思路是如果按照手写分解方法，总是将上一种分解方法的一个数拆开，所以最后一种分解方法永远是2+1+1+…(n-2个1)，所以倒数第二种分解方法就是将最后一种方法中的两个1或者1和2组合起来，即2+2+1+1…(n-4个1)或3+1+1+1..(n-3个1)。但一直没能用代码实现。 笔试结束后稍稍改变了一下思路，如果能先将该数的所有分解方法计算出来，再计算出所有加数完全相同的分解方法数，就能求得题目所要的分解方法次数。基于这个思路，问题的关键就在如何求得n的所有分解方法count1以及加数相同的分解方法count2。 柿子挑软的捏，先解决简单的问题，先求出count2。这个问题可以转换一下思路，如果n可以由i个m相加得到，那么m和i都是n的因数，所以这个问题就转化为求整数n的因数问题，这就只需要遍历从1到n1/2，假设得出结果为x。如果n是一个完全平方数，那2x-1，反之为2x。 接下来要求出count1。既然要求出所有的输出组合，那就意味一定会有一个遍历所有组合的过程，并且这个遍历一定是按照某种顺序的，所以关键问题在如何从第一种分解方法遍历到最后一种分解方法。先看一个例子： 3=1+1+1 =1+2 =2+1 =3 这个过程中的1+2和2+1本质上只是一种分解方法，所以应当先规定一个次序，定义了次序，剩下的就是让程序按照这个顺序执行下去。所以我们让数组从小到大出现，也就是说后一个加数永远大于等于前一个加数，这样就不会出现上面2+1的情况了，这样一来就能保证输出的唯一性了。 剩下的就是递归了，先遍历1开头的组合，当1开头的组合遍历完成时，就开始遍历2开头的，以2开头的分解方法中就没有加数1了，最小的加数为2；可以看出，第一个数最大的情况是取小于等于n/2的最大整数，如果第一个数大于n/2,而后一个数又必须大于n/2,那么两数相加一定会大于你，递归的思路如下： n=1+后续组合n=2+后续组合……n=n/2(前取整)+p (n为偶数时p=n/2,n为奇数时p=(n+1)/2) 思路差不多到这里，接下来是代码实现了。递归函数为total(n,start)，n为需要分解的整数，start表示当前遍历的第一个数字，start主要是为了去重复的。 javascript实现123456789101112131415161718192021222324252627282930313233//从1开始，后面加的每个数都大于等于1//1计算完了从2开始，一直遍历到比number/2小的最大整数var count1 = 0;//记录可能性总数（包括所有加数完全一样）var count2 = 0;//计算所有加数都相等情况的总数function list(number)&#123; if (parseInt(number)==NaN) &#123;//判断输入是否有效 return false; &#125; if (number&lt;3) &#123;//n小于3时直接输出0 return 0; &#125; total(number,1);//从第一个加数为1开始执行递归 for(var m = 1;m&lt;=parseInt(Math.sqrt(number));m++)&#123; if((number/m)==(parseInt(number/m)))&#123;//判断n的因数个数 count2++; &#125; &#125; console.log(count1,count2);//调试，可忽略 //判断n是否是完全平方数，若为完全平方，则根号n被多减去了一次，需要加上 if((parseInt(Math.sqrt(number)))==Math.sqrt(number))&#123; return count1-count2*2+2; &#125;else&#123; return count1-count2*2+1; &#125; &#125;function total(number,start)&#123; for(var i = start;i&lt;=number/2;i++)&#123; total(number-i,i);//从i开始可排除重复 count1++; &#125;&#125;console.log(list(9));//结果为27]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javascript中对象封装]]></title>
      <url>%2F2017%2F03%2F07%2Fmy-new-post%2F</url>
      <content type="text"><![CDATA[javascript中对象创建方法我们知道，JS是面向对象的。谈到面向对象，就不可避免的要涉及类的概念。不同于java这些强类型语言都有固定的定义类的语法，JS的能使用各种方法实现类和对象的封装。总结了目前想到的几种，后期有补充会继续更新： 1.工厂函数 工厂函数是一个返回特定对象的函数；每次调用这个函数都会生成一个新的对象，所以每个对象用的都有自己的方法版本（比如下面的showinfo），但其实所有对象都是共享的一个方法；所以这里可以进行优化,可以在工厂函数外定义该对象的方法，这样就只需要生成一遍对象方法。其次，工厂函数只解决了对象的创建问题，没能解决对象的识别问题。 12345678910111213function createPerson(name,age)&#123; var temp=new Object; temp.name=name; temp.age=age; temp.showInfo=function()&#123; console.log(this.name+&apos; is &apos;+this.age); &#125; return temp;//函数最后返回对象&#125;var person1=createPerson(&apos;wang&apos;,23);var person2=createPerson(&quot;he&quot;,25);person1.showInfo();person2.showInfo(); 优化方法: 12345678910function createPerson(name,age)&#123; var temp=new Object; temp.name=name; temp.age=age; temp.showInfo=showInfo; return temp;&#125;function showInfo()&#123; console.log(this.name+&apos; is &apos;+this.age); &#125; 2.构造函数 构造函数是指构造一个函数对象，每次需要用是需要先实例化。不过很显然，每次实例化一个对象都会创建自己的showInfo函数版本。这个问题同样可以和工厂函数采取一样的方法，将showInfo直接在person外定义。这种优化方法虽然能带来一些便利，但还是滋生了别的问题，比如showInfo是一个全局函数，但是一个全局函数只能被某个对象使用，显得有点名不符其实；更严重的是，如果定义了很多个全局函数，那这个自定义的引用类型就丝毫没有封装性了。好在这些问题可以通过原型模式解决。 1234567891011function Person(name,age)&#123; this.name=name; this.age=age; this.showInfo=function()&#123; console.log(this.name+&apos; is &apos;+this.age); &#125;&#125;var person1=new Person(&apos;wang&apos;,23);var person2=new Person(&quot;he&quot;,25);person1.showInfo();person2.showInfo(); 3.原型方法 该方式利用了对象的prototype属性，可把它看成创建新对象所依赖的原型。这里，用空构造函数来设置类名。然后把所有的方法和属性都直接赋予prototype属性。原型方法其实还有一个特点，我们给实例化出来的对象添加属性，当我们使用该属性时，搜索首先会是在这个在这个实例本身搜索，如果搜索不到，会从原型上搜索，直到得到结果。所以若实例和原型中有属性或方法重名，实例中的属性会屏蔽原型中的属性。 原型方式只能直接赋值，而不能通过给构造函数传递参数初始化属性的值。在用这种方式时，会遇到两个非常讨厌的问题。第一问题是采用这种方式必须创建每个对象后才能改变属性的默认值。而不能在创建每个对象时都会直接有自己所需要的属性值。这点很讨厌。第二个问题在于属性所指的是对象的时候。函数共享不会出现任何问题，但是对象共享却会出现问题（如下文的hobbies）。 12345678910111213function Person()&#123;&#125;Person.prototype.name=&quot;wang&quot;;Person.prototype.age=23;Person.prototype.hobbies=new Array(&quot;basketball&quot;,&quot;shoes&quot;);Person.prototype.showInfo=function()&#123; console.log(this.name+&apos; is &apos;+this.age);&#125;var person1=new Person();var person2=new Person();person1.hobbies.push(&quot;code&quot;);console.log(person1.hobbies);//输出&quot;basketball,shoes,code&quot;console.log(person1.hobbies);//输出&quot;basketball,shoes,code&quot; 4.构造函数+原型方式 这种方式的思想是将上两种思想结合一下，用构造函数定义对象的所有属性（包括普通属性和指向对象的属性），用原型方式定义对象的方法。这样每个实例都会有一份属于自己的实力属性的副本，但同时又共享着对方法的引用，极大地节省了内存，可谓是集两家之长。 12345678910111213function Person(name,age)&#123; this.name=name; this.age=age; this.hobbies=new Array(&quot;basketball&quot;,&quot;shoes&quot;);&#125;Person.prototype.showInfo=function()&#123; console.log(this.name+&apos; is &apos;+this.age); &#125;var person1=new Person(&apos;wang&apos;,23);var person2=new Person(&quot;he&quot;,25);person1.hobbies.push(&quot;code&quot;);console.log(person1.hobbies);//输出&quot;basketball,shoes,code&quot;console.log(person2.hobbies);//输出&quot;basketball,shoes&quot; 5.动态原型模式 这种方法在if处判断了是否初次运行构造函数。初次运行时，this指向的实例对象并没有showInfo这个方法，因此会进入if方法体内进行原型方法的定义。第二次运行时，this指向的实例对象的原型上已经有了showInfo方法，就不会进行二次构造，避免了原型方法的重复定义。除此之外，如果一个方法没有初始化，那代表所有属性和方法都没有初始化，所以只需要对其中一个方法进行判断就好。 其实一开始也没能发现这种方法比上一种方法的好处，然后查阅发现这是为了解决有其他OO语言开发经验人的困惑，他们对独立开的构造函数和原型感到很困惑，动态原型就可以将所有信息都封装在函数中了。顺便说一句，这种模式产生的对象，可以用instanceof来确定它的类型。 1234567891011function person(name,age)&#123; this.name=name; this.age= age; if (typeof this.showInfo==&apos;undefined&apos;) &#123; person.prototype.showInfo=function()&#123; return this.name+&apos; is &apos;+this.age; &#125; &#125;&#125;var person1 = new person(&apos;wang&apos;,23);console.log(person1.showInfo());//wang is 23 update at 2017.04.09 6.寄生构造函数先不解释这种方法的，先看一个例子。 1234567891011function createPerson(name,age)&#123; var person = &#123;&#125;; person.name = name; person.age = age; person.showInfo = function()&#123; return this.name+&apos; is &apos;+this.age; &#125;; return person; &#125; var person1 = new createPerson(&quot;wang&quot;,23); console.log(person1.showInfo());//wang is 23 我自己在学习的时候不够仔细，刚接触这种方法时觉得这不就是工厂函数方法吗？在函数中创建一个新的对象，最后将对象当做返回值，直接看来工厂函数也是这么做的。那么在看一下下一个例子(此例子网上直接拷贝，非原创)。 12345678910function SpecialArray()&#123; var values = new Array(); values.push.apply(values, arguments); values.toPipedString = function()&#123; return this.join(&quot;|&quot;); &#125; return values;&#125;var a = new SpecialArray(2,6,8);a.toPipedString();//2|6|8 确实工厂构造方法和寄生构造方法没有本质区别，区别就在实例化的时候，工厂函数直接用了函数返回的对象，而寄生方法用了new关键字。new关键字会先新建一个空对象，这个对象会继承该函数的原型，最后this会绑定到新的对象上。所以这里的toPipedString方法会在原型上，也就是说普通的array也可以用toPipedString方法。总结一下就是寄生构造方法可以js原生的构造函数增加一些新的方法。 这种方法返回的独享和构造函数或构造函数原型之间没什么关系，构造函数产生的对象和构造函数外部创建的对象没什么不同，也就是说不能通过instanceof来确定其对象类型，基于这一点，个人建议还是不要用这种方法了。 7.稳妥构造函数模式 稳妥对象指的是没有公共属性和方法，看下面的代码可以知道，构造过程中没有引用this，生成实例的时候也没有用new方法，只有showInfo方法可以访问到name和age值，并且无论接下来的代码如何给person1加属性，name和age两个值也是不可能改变的。稳妥构造函数模式提供的这种安全性，使得他非常适合在某些安全的环境（可惜没有实战使用过。。。汗）。其实个人觉得稳妥构造和工厂还是有点像，都是返回一个对象，不过看下面的例子，可以很直观的说明。 12345678910111213141516171819202122232425262728function createPerson(name,age)&#123; var person = new Object(); person.showInfo = function()&#123; console.log(name+&apos; is &apos;+age); &#125;; return person; &#125; var person1 = createPerson(&apos;wangwei&apos;,23); person1.showInfo(); //wangwei is 23console.log(person1.name);//undefined person1.name = &apos;wangxiaowei&apos;;console.log(person1.name);//wangxiaoweiperson1.showInfo(); //wangwei is 23//---------以上为稳妥构造，下面是工厂函数构造------------function createPerson(name,age)&#123; var temp=new Object; temp.name=name; temp.age=age; temp.showInfo=function()&#123; console.log(this.name+&apos; is &apos;+this.age); &#125; return temp;//函数最后返回对象&#125;var person1=createPerson(&apos;wang&apos;,23);person1.name=&apos;wangxiaowei&apos;;person1.showInfo();//wangxiaowei is 23]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[剑指offer javascript实现]]></title>
      <url>%2F2017%2F03%2F06%2Fhello-world%2F</url>
      <content type="text"><![CDATA[剑指offer javascript实现 1.输入一个链表，从尾到头打印链表每个节点的值 123456789101112function printListFromTailToHead(head)&#123; var node= head; var list=[]; while(node!=null)&#123; list.unshift(node.val); node=node.next; &#125; return list;&#125;module.exports = &#123; printListFromTailToHead : printListFromTailToHead&#125;; 2.请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 12345678function replaceSpace(str)&#123; var arr = str.split(&apos; &apos;); str = arr.join(&apos;%20&apos;); return str;&#125;module.exports = &#123; replaceSpace : replaceSpace&#125;; 3.用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 1234567891011121314151617181920var stack = [];var stack_temp = [];function push(node)&#123; stack.push(node);&#125;function pop()&#123; if(stack_temp.length==0)&#123;//若不为空直接返回之前一步最后压入的元素即可 while(stack.length&gt;0)&#123; stack_temp.push(stack.pop()); &#125; &#125; return stack_temp.pop();&#125;module.exports = &#123; push : push, pop : pop&#125;; 4.把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 123456789101112131415//方法1:这是比较low的解决方法，直接遍历数组，通过前后元素的大小比较确定function minNumberInRotateArray(rotateArray)&#123; if(rotateArray.length==0)&#123; return 0; &#125; for(var i=0;i&lt;rotateArray.length;i++)&#123; if(rotateArray[i+1]&lt;rotateArray[i])&#123; return rotateArray[i+1]; &#125; &#125; &#125;module.exports = &#123; minNumberInRotateArray : minNumberInRotateArray&#125;; 12345678910111213141516171819202122232425262728//方法2效率较高，避免了一个一个比较function minNumberInRotateArray(rotateArray)&#123; if(rotateArray.length==0)&#123; return 0; &#125; var start= 0; var end = rotateArray.length-1; var middle = 0; while(rotateArray[start]&gt;=rotateArray[end])&#123; if(start==end-1)&#123; middle = end; break; &#125; middle=Math.floor((start+end)/2); if(rotateArray[middle]&gt;=rotateArray[start])&#123; start=middle; &#125; else if(rotateArray[middle]&lt;rotateArray[start])&#123; end=middle; &#125; &#125; return rotateArray[middle];&#125;module.exports = &#123; minNumberInRotateArray : minNumberInRotateArray&#125;; 5.大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。 tip:这道题其实可以用递归，代码或许会更简洁，但是递归在这里有严重的效率问题，比如说求f(10),必须先求f(8)和f(9)，f(9)又要计算f(7)和f(8)，可以发现f(8)被重复计算。 1234567891011121314151617181920function Fibonacci(n)&#123; var sum=0; var first=1; var second=1; if(n==1||n==2)&#123; sum = 1; &#125;else&#123; var i=3; while(i&lt;=n)&#123; sum = first+second; first = second; second = sum; i++; &#125; &#125; return sum;&#125;module.exports = &#123; Fibonacci : Fibonacci&#125;; 6.一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 解题思路：青蛙最后一步可以跳一级或者两级;那么假定第一次跳的是一阶，那么剩下的是n-1个台阶，跳法是f(n-1);假定第一次跳的是2阶，那么剩下的是n-2个台阶，跳法是f(n-2);所以最后一步的跳法f(n)=f(n-1)+f(n-2) 12345678910111213141516171819202122function jumpFloor(number)&#123; if(number==0)&#123; return 0; &#125;else if(number&gt;0&amp;&amp;number&lt;3)&#123; return number; &#125;else&#123; var first =1; var second = 2; var sum; var i=3; while(i&lt;=number)&#123; sum = first+second; first = second; second = sum; i++ &#125; return &gt;; &#125;&#125;module.exports = &#123; jumpFloor : jumpFloor&#125;; 7.一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法 解题思路：若将n级台阶的跳法设为f(n)，可以想到f(n)=f(n-1)+f(n-2)+f(n-3)….+f(1)，而f(n-1)=f(n-2)+f(n-3)….+f(1)，所以f(n)=2f(n-1)。所以代码思路就很清晰了 12345678910function jumpFloorII(number)&#123; if(number == 0)&#123;//特殊情况单独拿出来讨论一下 return 0; &#125;else&#123; return Math.pow(2, number-1) &#125; &#125;module.exports = &#123; jumpFloorII : jumpFloorII&#125;; 8.我们可以用2 1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2 1的小矩形无重叠地覆盖一个2 * n的大矩形，总共有多少种方法？ 解题思路：这和上面一样也是一道斐波那契数列的题目，具体思路和第一个青蛙跳台阶差不多 123456789101112131415161718192021function rectCover(number)&#123; if(number==2||number==1||number==0)&#123; return number; &#125;else&#123; var sum; var first= 1; var second = 2; var i=3; while(i&lt;=number)&#123; sum = first+second; first = second; second = sum; i++; &#125; return sum; &#125; &#125;module.exports = &#123; rectCover : rectCover&#125;; 9.输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 12345678910111213141516function reOrderArray(array)&#123; var first=[];//按顺序存奇数 var second=[]; for(var i=0;i&lt;array.length;i++)&#123; if((array[i]%2)==0)&#123; second.push(array[i]); &#125;else&#123; first.push(array[i]); &#125; &#125; first=first.concat(second); return first;&#125;module.exports = &#123; reOrderArray : reOrderArray&#125;;]]></content>
    </entry>

    
  
  
</search>
