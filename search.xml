<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[my new post]]></title>
      <url>%2F2017%2F03%2F07%2Fmy-new-post%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[剑指offer javascript实现]]></title>
      <url>%2F2017%2F03%2F06%2Fhello-world%2F</url>
      <content type="text"><![CDATA[剑指offer javascript实现 1.输入一个链表，从尾到头打印链表每个节点的值 123456789101112function printListFromTailToHead(head)&#123; var node= head; var list=[]; while(node!=null)&#123; list.unshift(node.val); node=node.next; &#125; return list;&#125;module.exports = &#123; printListFromTailToHead : printListFromTailToHead&#125;; 2.请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 12345678function replaceSpace(str)&#123; var arr = str.split(&apos; &apos;); str = arr.join(&apos;%20&apos;); return str;&#125;module.exports = &#123; replaceSpace : replaceSpace&#125;; 3.用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 1234567891011121314151617181920var stack = [];var stack_temp = [];function push(node)&#123; stack.push(node);&#125;function pop()&#123; if(stack_temp.length==0)&#123;//若不为空直接返回之前一步最后压入的元素即可 while(stack.length&gt;0)&#123; stack_temp.push(stack.pop()); &#125; &#125; return stack_temp.pop();&#125;module.exports = &#123; push : push, pop : pop&#125;; 4.把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 123456789101112131415//方法1:这是比较low的解决方法，直接遍历数组，通过前后元素的大小比较确定function minNumberInRotateArray(rotateArray)&#123; if(rotateArray.length==0)&#123; return 0; &#125; for(var i=0;i&lt;rotateArray.length;i++)&#123; if(rotateArray[i+1]&lt;rotateArray[i])&#123; return rotateArray[i+1]; &#125; &#125; &#125;module.exports = &#123; minNumberInRotateArray : minNumberInRotateArray&#125;; 12345678910111213141516171819202122232425262728//方法2效率较高，避免了一个一个比较function minNumberInRotateArray(rotateArray)&#123; if(rotateArray.length==0)&#123; return 0; &#125; var start= 0; var end = rotateArray.length-1; var middle = 0; while(rotateArray[start]&gt;=rotateArray[end])&#123; if(start==end-1)&#123; middle = end; break; &#125; middle=Math.floor((start+end)/2); if(rotateArray[middle]&gt;=rotateArray[start])&#123; start=middle; &#125; else if(rotateArray[middle]&lt;rotateArray[start])&#123; end=middle; &#125; &#125; return rotateArray[middle];&#125;module.exports = &#123; minNumberInRotateArray : minNumberInRotateArray&#125;; 5.大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。 1234567891011121314151617181920function Fibonacci(n)&#123; var sum=0; var first=1; var second=1; if(n==1||n==2)&#123; sum = 1; &#125;else&#123; var i=3; while(i&lt;=n)&#123; sum = first+second; first = second; second = sum; i++; &#125; &#125; return sum;&#125;module.exports = &#123; Fibonacci : Fibonacci&#125;; 6.一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 解题思路：青蛙最后一步可以跳一级或者两级;那么假定第一次跳的是一阶，那么剩下的是n-1个台阶，跳法是f(n-1);假定第一次跳的是2阶，那么剩下的是n-2个台阶，跳法是f(n-2);所以最后一步的跳法f(n)=f(n-1)+f(n-2) 12345678910111213141516171819202122function jumpFloor(number)&#123; if(number==0)&#123; return 0; &#125;else if(number&gt;0&amp;&amp;number&lt;3)&#123; return number; &#125;else&#123; var first =1; var second = 2; var sum; var i=3; while(i&lt;=number)&#123; sum = first+second; first = second; second = sum; i++ &#125; return &gt;; &#125;&#125;module.exports = &#123; jumpFloor : jumpFloor&#125;; 7.一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法 解题思路：若将n级台阶的跳法设为f(n)，可以想到f(n)=f(n-1)+f(n-2)+f(n-3)….+f(1)，而f(n-1)=f(n-2)+f(n-3)….+f(1)，所以f(n)=2f(n-1)。所以代码思路就很清晰了 12345678910function jumpFloorII(number)&#123; if(number == 0)&#123;//特殊情况单独拿出来讨论一下 return 0; &#125;else&#123; return Math.pow(2, number-1) &#125; &#125;module.exports = &#123; jumpFloorII : jumpFloorII&#125;; 8.我们可以用2的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 解题思路：这和上面一样也是一道斐波那契数列的题目，具体思路和第一个青蛙跳台阶差不多 123456789101112131415161718192021function rectCover(number)&#123; if(number==2||number==1||number==0)&#123; return number; &#125;else&#123; var sum; var first= 1; var second = 2; var i=3; while(i&lt;=number)&#123; sum = first+second; first = second; second = sum; i++; &#125; return sum; &#125; &#125;module.exports = &#123; rectCover : rectCover&#125;; 9.输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 12345678910111213141516function reOrderArray(array)&#123; var first=[];//按顺序存奇数 var second=[]; for(var i=0;i&lt;array.length;i++)&#123; if((array[i]%2)==0)&#123; second.push(array[i]); &#125;else&#123; first.push(array[i]); &#125; &#125; first=first.concat(second); return first;&#125;module.exports = &#123; reOrderArray : reOrderArray&#125;;]]></content>
    </entry>

    
  
  
</search>
